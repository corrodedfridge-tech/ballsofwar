<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Territory Battle Pro: Image Units</title>
    <style>
        :root {
            --bg-color: #050505;
            --text-color: #fff;
            --accent: #FFD700;
            --swap-power: #E0B0FF; /* Magenta/Purple for Swap */
            --danger: #ff4444;
            --bar-bg: #000;
            --toggle-on: #4CAF50;
            --toggle-off: #555;
            --template-color: #0088cc; /* Blue for templates */
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        #app-layout {
            display: grid;
            grid-template-rows: auto 1fr auto; 
            height: 100%;
            width: 100%;
            transition: all 0.3s ease;
        }

        #top-bar {
            grid-row: 1;
            grid-column: 1;
            background: var(--bar-bg); 
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 40px;
            z-index: 20;
            box-sizing: border-box;
            width: 100%;
            pointer-events: auto;
            border-bottom: 1px solid #333;
        }

        .player-status {
            display: flex;
            flex-direction: column;
            width: 35%;
            gap: 5px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        }

        .player-name {
            font-size: 1.1rem;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 1px;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
        }

        .health-track {
            width: 100%;
            height: 12px;
            background: rgba(255,255,255,0.1);
            border-radius: 6px;
            overflow: hidden;
            position: relative;
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255,255,255,0.1);
        }

        .health-fill {
            height: 100%;
            width: 100%;
            transition: width 0.2s, background-color 0.3s;
        }

        #game-area {
            position: relative;
            background: #0a0a0a;
            width: 100%;
            height: 100%;
            overflow: hidden;
            grid-row: 2; 
            grid-column: 1;
            z-index: 1;
            /* CRITICAL: Use flexbox to center the canvas element */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        canvas {
            display: block;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
            background-color: var(--bg-color); 
            /* Added margin to ensure the canvas is never flush against the game-area edges */
            margin: 10px; 
        }

        #bottom-bar {
            grid-row: 3;
            grid-column: 1;
            background: var(--bar-bg); 
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            z-index: 20;
            padding: 10px 0; 
            pointer-events: auto;
            border-top: 1px solid #333;
        }

        .ui-hidden #top-bar, .ui-hidden #bottom-bar { 
            display: none !important; 
        }

        /* Buttons and Toggles */
        .control-group { display: flex; align-items: center; gap: 15px; }

        .speed-btn, .toggle-btn {
            background: rgba(0,0,0,0.5);
            border: 1px solid #555;
            color: #ccc;
            padding: 8px 16px;
            font-size: 0.9rem;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            backdrop-filter: blur(4px);
            transition: background 0.2s, border-color 0.2s;
        }
        .speed-btn:hover, .toggle-btn:hover { background: #444; }
        .speed-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: #000;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
        }
        
        .toggle-btn { 
            padding: 8px 12px;
            min-width: 140px;
        }
        .toggle-btn.on {
            background-color: var(--toggle-on);
            border-color: var(--toggle-on);
            color: #fff;
        }
        .toggle-btn.border-on {
            background-color: #2e7d32; /* Darker Green */
            border-color: #2e7d32;
            color: #fff;
        }

        .btn-stop {
            background-color: var(--danger);
            border: none;
            color: white;
            padding: 8px 24px;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
            margin-left: 20px;
            box-shadow: 0 0 10px rgba(255,68,68,0.3);
        }

        /* Overlays */
        .overlay {
            position: absolute; 
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 50;
            transition: opacity 0.3s;
            overflow-y: auto; /* Allow scrolling on smaller screens */
            padding: 20px;
            box-sizing: border-box;
        }
        .hidden { opacity: 0; pointer-events: none; z-index: -1; }

        /* MENU ADJUSTMENTS */
        h1 {
            font-size: clamp(2rem, 5vw, 4rem);
            text-transform: uppercase;
            background: linear-gradient(to right, #fff, #888);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 20px; 
            text-align: center;
        }

        .menu-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); 
            gap: 20px; 
            margin-bottom: 30px; 
            width: 95%; 
            max-width: 950px; 
        }

        .player-config {
            background: rgba(255,255,255,0.05);
            padding: 20px; 
            border-radius: 10px;
            border: 1px solid #333;
            display: flex;
            flex-direction: column;
            gap: 15px; 
            font-size: 0.9rem; 
        }

        .config-title {
            color: #aaa;
            font-size: 0.9rem;
            font-weight: bold;
            text-transform: uppercase;
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
            margin-bottom: 5px;
        }

        .input-group label {
            display: block;
            font-size: 0.75rem; 
            margin-bottom: 5px;
            color: #888;
        }

        .input-group input:not([type="color"]):not([type="checkbox"]), 
        .input-group select {
            width: 100%;
            padding: 8px; 
            background: #222;
            border: 1px solid #444;
            color: white;
            border-radius: 4px;
            box-sizing: border-box;
            font-size: 0.9rem;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }

        .player-config input[type="file"] {
            padding: 3px;
            font-size: 0.8rem;
            border: 1px solid #444;
            background: #222;
            border-radius: 4px;
            color: #fff;
            width: 100%;
            box-sizing: border-box;
        }

        .image-preview-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }
        
        .image-preview {
            width: 40px; 
            height: 40px; 
            border-radius: 50%; 
            border: 2px dashed #888;
            display: inline-flex; 
            align-items: center; 
            justify-content: center;
            font-size: 0.6rem; 
            color: #888; 
            overflow: hidden;
            background-size: cover; 
            background-position: center;
            flex-shrink: 0;
        }
        
        .checkbox-label {
            font-size: 0.9rem;
        }

        .btn-start {
            background: linear-gradient(135deg, #FFD700, #FFA500);
            color: #000;
            font-size: 1.2rem; 
            padding: 15px 60px; 
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.2);
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.2s ease;
        }
        .btn-start:hover { transform: scale(1.05); box-shadow: 0 0 30px rgba(255, 215, 0, 0.4); }
        .btn-secondary {
            background: #444; color: #fff; padding: 10px 30px;
            border: none; border-radius: 4px; cursor: pointer; font-weight: bold; margin-top: 10px;
        }

        /* NEW SUBTLE TEMPLATE STYLES */
        .subtle-template-btn {
            background-color: #444;
            color: #fff;
            border: 1px solid #666;
            padding: 4px 8px;
            font-size: 0.8rem;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s;
            margin-right: 5px; 
            margin-bottom: 5px;
        }
        .subtle-template-btn:hover {
            background-color: var(--template-color); 
            border-color: var(--template-color);
        }

    </style>
</head>
<body>

    <div id="app-layout" class="ui-hidden">
        
        <!-- Top Bar (Grid Row 1) -->
        <div id="top-bar">
            <div class="player-status">
                <div class="health-track"><div id="hp-bar-1" class="health-fill" style="background: #00d2ff; width: 100%;"></div></div>
                <div id="name-display-1" class="player-name" style="color: #00d2ff; text-align: left;">Blue Empire</div>
            </div>
            <div style="font-weight:900; color:#fff; font-size:1.5rem; text-shadow:0 0 10px #000;">VS</div>
            <div class="player-status">
                <div class="health-track"><div id="hp-bar-2" class="health-fill" style="background: #ff2a6d; width: 100%;"></div></div>
                <div id="name-display-2" class="player-name" style="color: #ff2a6d; text-align: right;">Red Kingdom</div>
            </div>
        </div>

        <!-- Game Area (Grid Row 2 - Takes up all remaining space) -->
        <div id="game-area">
            <canvas id="simCanvas"></canvas>
            
            <div id="main-menu" class="overlay">
                <!-- MAIN TITLE: Balls Of War -->
                <h1>Balls Of War: Territory Sim</h1>
                
                <div class="menu-grid">
                    <!-- SCENARIO & GAME PARAMETERS -->
                    <div class="player-config" style="grid-column: 1 / -1; display:flex; flex-direction: column; gap:10px;">
                        <div style="display: flex; flex-direction: column; gap: 8px;">
                            <label style="color: #ccc; font-weight: 600; font-size:1rem; margin-bottom: 5px;">Scenario Templates (Map Rules)</label>
                            <div id="scenario-buttons">
                                <button class="subtle-template-btn" onclick="applyScenario('Duel')">1v1 Duel</button>
                                <button class="subtle-template-btn" onclick="applyScenario('War')">Massive War</button>
                                <button class="subtle-template-btn" onclick="applyScenario('Skirmish')">Skirmish</button>
                                <button class="subtle-template-btn" onclick="applyScenario('Blitz')">Blitz</button>
                                <button class="subtle-template-btn" onclick="applyScenario('Trench')">Trench Warfare</button>
                            </div>
                        </div>

                        <div style="display:flex; flex-wrap: wrap; justify-content: space-between; gap:15px; margin-top: 10px;">
                             <div class="input-group">
                                <label>Grid Size (Cols x Rows)</label>
                                <div style="display:flex; gap:10px;">
                                    <input type="number" id="colsInput" value="15" style="width:70px;">
                                    <input type="number" id="rowsInput" value="15" style="width:70px;">
                                </div>
                            </div>
                            <div class="input-group">
                                <label>Balls Per Player</label>
                                <input type="number" id="ballCountInput" value="1" min="1" max="100" style="width:80px;">
                            </div>
                            <div class="input-group">
                                <label>Ball Speed (Units/Frame)</label>
                                <input type="number" id="ballSpeedInput" value="0.10" min="0.01" step="0.01" style="width:120px;">
                            </div>
                            <div class="input-group">
                                <label>Display Options</label>
                                <label class="checkbox-label">
                                    <input type="checkbox" id="territoryNameToggleMenu">
                                    Show Territory Names
                                </label>
                                <label class="checkbox-label" style="margin-top: 5px;">
                                    <input type="checkbox" id="borderEffectToggleMenu">
                                    Show Border Effect
                                </label>
                            </div>
                        </div>
                    </div>
                    
                    <!-- PLAYER 1 CONFIG -->
                    <div class="player-config">
                        <div class="config-title">Player 1 Configuration</div>
                        <div class="input-group"><label>Name</label><input type="text" id="p1-name" value="Blue Empire"></div>
                        <div class="input-group"><label>Color (Fallback)</label><input type="color" id="p1-color" value="#00d2ff"></div>
                        <div class="input-group">
                            <label>Unit Image (Optional)</label>
                            <div class="image-preview-container">
                                <input type="file" id="p1-image-upload" accept="image/*" onchange="handleImageUpload(0, event)">
                                <div id="p1-preview" class="image-preview">P1</div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- PLAYER 2 CONFIG -->
                    <div class="player-config">
                        <div class="config-title">Player 2 Configuration</div>
                        <div class="input-group"><label>Name</label><input type="text" id="p2-name" value="Red Kingdom"></div>
                        <div class="input-group"><label>Color (Fallback)</label><input type="color" id="p2-color" value="#ff2a6d"></div>
                        <div class="input-group">
                            <label>Unit Image (Optional)</label>
                            <div class="image-preview-container">
                                <input type="file" id="p2-image-upload" accept="image/*" onchange="handleImageUpload(1, event)">
                                <div id="p2-preview" class="image-preview">P2</div>
                            </div>
                        </div>
                    </div>
                </div>
                <!-- START BUTTON -->
                <button class="btn-start" onclick="startSimulation()">START WAR</button>
            </div>

            <div id="victory-screen" class="overlay hidden">
                <h1 id="winner-text">BLUE WINS!</h1>
                <h2 style="color:#aaa; margin-top:-20px;">Enemy Eliminated</h2>
                <button class="btn-secondary" onclick="resetToMenu()">RETURN TO MENU</button>
            </div>
        </div>

        <!-- Bottom Bar (Grid Row 3) -->
        <div id="bottom-bar">
            <!-- Territory Name Toggle In-Game -->
            <button id="territoryNameToggleGame" class="toggle-btn" onclick="toggleTerritoryNames()">Names: OFF</button>
            
            <!-- Border Effect Toggle In-Game -->
            <button id="borderEffectToggleGame" class="toggle-btn on" onclick="toggleBorderEffect()">Borders: OFF</button>

            <span style="color:#888; font-size: 0.8rem; font-weight:bold; letter-spacing:1px; margin-left: 15px;">SPEED</span>
            <button class="speed-btn active" onclick="setSpeed(1)">1x</button>
            <button class="speed-btn" onclick="setSpeed(2)">2x</button>
            <button class="speed-btn" onclick="setSpeed(4)">4x</button>
            <button class="speed-btn" onclick="setSpeed(8)">8x</button>
            <button class="btn-stop" onclick="stopSimulation()">STOP</button>
        </div>
    </div>

    <script>
        // --- GLOBALS ---
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        const appLayout = document.getElementById('app-layout');
        const gameArea = document.getElementById('game-area');
        
        // Constants
        const MAX_BALL_HEALTH = 100;
        const POWERUP_BOMB = 0; 
        const POWERUP_SWAP = 1; 
        const SWAP_RARITY_THRESHOLD = 0.1; 
        const MIN_CHUNK_SIZE_FOR_LABEL = 8; 
        const DARKEN_AMOUNT = 0.2; 
        const MAP_SCALE_FACTOR = 0.95; 

        // Config 
        let COLS = 15; 
        let ROWS = 15;
        let TILE_SIZE = 10;
        let OFFSET_X = 0;
        let OFFSET_Y = 0;
        
        // Game State
        let grid = []; 
        let balls = [];
        let powerUp = null; 
        let animationId;
        let isRunning = false;
        let simulationSpeed = 1;
        let players = []; 
        let showTerritoryNames = false; 
        let showBorderEffect = false; 
        
        // UI Refs (Input fields)
        const colsInput = document.getElementById('colsInput');
        const rowsInput = document.getElementById('rowsInput');
        const ballCountInput = document.getElementById('ballCountInput');
        const ballSpeedInput = document.getElementById('ballSpeedInput');
        const p1NameInput = document.getElementById('p1-name');
        const p2NameInput = document.getElementById('p2-name');
        const p1ColorInput = document.getElementById('p1-color');
        const p2ColorInput = document.getElementById('p2-color');
        const p1Preview = document.getElementById('p1-preview');
        const p2Preview = document.getElementById('p2-preview');

        // UI Refs (Other elements)
        const mainMenu = document.getElementById('main-menu');
        const victoryScreen = document.getElementById('victory-screen');
        const hpBar1 = document.getElementById('hp-bar-1');
        const hpBar2 = document.getElementById('hp-bar-2');
        const nameDisp1 = document.getElementById('name-display-1');
        const nameDisp2 = document.getElementById('name-display-2');
        const winnerText = document.getElementById('winner-text');
        const speedBtns = document.querySelectorAll('.speed-btn');
        const nameToggleMenu = document.getElementById('territoryNameToggleMenu');
        const nameToggleGame = document.getElementById('territoryNameToggleGame');
        const borderToggleMenu = document.getElementById('borderEffectToggleMenu');
        const borderToggleGame = document.getElementById('borderEffectToggleGame');
        
        // --- SCENARIO DATA (Kept the useful presets) ---

        const SCENARIOS = {
            'Duel': {
                cols: 15, rows: 15, balls: 1, speed: 0.10, 
                showNames: false, showBorders: false, 
            },
            'War': {
                cols: 80, rows: 80, balls: 10, speed: 0.35, 
                showNames: true, showBorders: true,
            },
            'Skirmish': {
                cols: 30, rows: 30, balls: 2, speed: 0.15, 
                showNames: false, showBorders: false,
            },
            'Blitz': {
                cols: 50, rows: 50, balls: 5, speed: 0.50, 
                showNames: false, showBorders: false,
            },
            'Trench': {
                cols: 100, rows: 20, balls: 3, speed: 0.10, 
                showNames: false, showBorders: true,
            }
        };

        // Initialize players array to hold configuration, including image data
        players = [
            { id: 0, name: "Blue Empire", color: "#00d2ff", maxHealth: 0, loadedImage: null },
            { id: 1, name: "Red Kingdom", color: "#ff2a6d", maxHealth: 0, loadedImage: null }
        ];

        // --- IMAGE HANDLING ---

        /**
         * Handles image file selection, converts it to a data URL, loads it, 
         * and stores it in the player configuration.
         * @param {number} playerId - 0 for P1, 1 for P2.
         * @param {Event} event - The file input change event.
         */
        function handleImageUpload(playerId, event) {
            const file = event.target.files[0];
            const previewEl = playerId === 0 ? p1Preview : p2Preview;
            const playerConfig = players[playerId];

            if (!file) {
                // Clear image
                playerConfig.loadedImage = null;
                previewEl.style.backgroundImage = 'none';
                previewEl.innerText = `P${playerId + 1}`;
                return;
            }

            const reader = new FileReader();
            
            reader.onload = (e) => {
                const dataUrl = e.target.result;
                
                // 1. Create a new Image object
                const img = new Image();
                
                img.onload = () => {
                    // 2. Store the loaded Image object in the player config
                    playerConfig.loadedImage = img;
                    console.log(`Player ${playerId + 1} image loaded successfully.`);
                };
                
                img.onerror = () => {
                    console.error("Error loading image for Canvas drawing.");
                    playerConfig.loadedImage = null;
                };

                img.src = dataUrl;

                // 3. Update the menu preview element
                previewEl.style.backgroundImage = `url('${dataUrl}')`;
                previewEl.innerText = '';
                previewEl.style.border = `2px solid ${playerConfig.color}`;
            };
            
            reader.readAsDataURL(file);
        }


        // --- UTILITY FUNCTIONS ---

        /**
         * Function to darken a hex color by a certain percentage.
         */
        function darkenHexColor(hex, percent) {
            let r = parseInt(hex.substring(1, 3), 16);
            let g = parseInt(hex.substring(3, 5), 16);
            let b = parseInt(hex.substring(5, 7), 16);

            r = Math.floor(r * (1 - percent));
            g = Math.floor(g * (1 - percent));
            b = Math.floor(b * (1 - percent));

            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));

            const toHex = (c) => c.toString(16).padStart(2, '0');
            return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
        }

        /**
         * Checks if a tile at (x, y) is a border tile (touches an enemy tile).
         */
        function isBorderTile(x, y, ownerIndex) {
            if (!showBorderEffect) return false;

            const neighbors = [
                { dx: 0, dy: -1 }, { dx: 0, dy: 1 }, 
                { dx: -1, dy: 0 }, { dx: 1, dy: 0 }
            ];

            for (const { dx, dy } of neighbors) {
                const nx = x + dx;
                const ny = y + dy;

                if (ny >= 0 && ny < ROWS && nx >= 0 && nx < COLS) {
                    if (grid[ny][nx] !== ownerIndex) {
                        return true;
                    }
                }
            }
            return false;
        }


        // --- RESIZE LOGIC (Guaranteed Square Tiles) ---
        function handleResize() {
            const availW = gameArea.clientWidth;
            const availH = gameArea.clientHeight;
            
            const paddedW = availW * MAP_SCALE_FACTOR;
            const paddedH = availH * MAP_SCALE_FACTOR;
            
            const tileW = paddedW / COLS;
            const tileH = paddedH / ROWS;
            
            TILE_SIZE = Math.floor(Math.min(tileW, tileH)); 
            TILE_SIZE = Math.max(1, TILE_SIZE); 

            const mapW = TILE_SIZE * COLS;
            const mapH = TILE_SIZE * ROWS;
            
            canvas.width = mapW;
            canvas.height = mapH;
            
            OFFSET_X = 0;
            OFFSET_Y = 0;
            
            if(!isRunning && grid.length > 0) {
                if (players.length < 2) return; 
                ctx.clearRect(0,0, canvas.width, canvas.height);
                drawGrid();
                drawTerritoryLabels();
            }
        }
        window.addEventListener('resize', handleResize);

        function calculateTotalHealth(playerIndex) {
            return balls.filter(b => b.owner === playerIndex)
                        .reduce((total, ball) => total + ball.health, 0);
        }

        function handleHealthSwap() {
            const p1Max = players[0].maxHealth;
            const p2Max = players[1].maxHealth;

            const p1Current = calculateTotalHealth(0);
            const p2Current = calculateTotalHealth(1);

            const p1Ratio = p1Current / p1Max;
            const p2Ratio = p2Current / p2Max;

            const p1TargetHP = p2Ratio * p1Max; 
            const p2TargetHP = p1Ratio * p2Max; 

            distributeNewHealth(0, p1TargetHP);
            distributeNewHealth(1, p2TargetHP);
            
            updateHealthBars(); 
        }

        function distributeNewHealth(playerIndex, newTotalHealth) {
            const playerBalls = balls.filter(b => b.owner === playerIndex);
            if (playerBalls.length === 0) return;

            const currentTotalHealth = playerBalls.reduce((sum, ball) => sum + ball.health, 0);
            if (currentTotalHealth === 0) return; 

            const multiplier = newTotalHealth / currentTotalHealth;

            playerBalls.forEach(ball => {
                let newHealth = ball.health * multiplier;
                newHealth = Math.min(MAX_BALL_HEALTH, newHealth);
                
                if (newTotalHealth > 0) {
                    newHealth = Math.max(1, newHealth); 
                } else {
                    newHealth = 0; 
                }

                ball.health = newHealth;
            });
        }

        // --- CLASSES ---
        
        class Ball {
            constructor(x, y, dx, dy, ownerIndex) {
                this.x = x;
                this.y = y;
                this.dx = dx;
                this.dy = dy;
                this.owner = ownerIndex;
                this.radius = 0.7; 
                this.bounceCooldown = 0;
                this.powerUpType = null; 
                this.health = MAX_BALL_HEALTH; 
            }

            update() {
                if (this.bounceCooldown > 0) this.bounceCooldown--;

                let nextX = this.x + this.dx;
                let nextY = this.y + this.dy;

                // Map Boundaries
                if (nextX - this.radius < 0 || nextX + this.radius > COLS) {
                    this.dx = -this.dx;
                    nextX = this.x + this.dx;
                }
                if (nextY - this.radius < 0 || nextY + this.radius > ROWS) {
                    this.dy = -this.dy;
                    nextY = this.y + this.dy;
                }

                // PowerUp Collection
                if (powerUp && powerUp.active) {
                    const dist = Math.hypot(this.x - powerUp.x, this.y - powerUp.y);
                    if (dist < (this.radius + 1.2)) {
                        powerUp.active = false;
                        this.powerUpType = powerUp.type; 
                    }
                }

                // Grid Interaction
                let checkX = this.x + (this.dx * 1.5);
                let checkY = this.y + (this.dy * 1.5);
                
                let gx = Math.floor(checkX);
                let gy = Math.floor(checkY);
                gx = Math.max(0, Math.min(COLS - 1, gx));
                gy = Math.max(0, Math.min(ROWS - 1, gy));

                const tileOwner = grid[gy][gx];
                
                if (tileOwner !== this.owner) {
                    
                    if (this.powerUpType !== null) {
                        this.usePowerUp(gx, gy);
                    }
                    else {
                        grid[gy][gx] = this.owner;
                    }

                    if (this.bounceCooldown === 0) {
                        let pgx = Math.floor(this.x);
                        let pgy = Math.floor(this.y);
                        
                        let hitX = pgx !== gx;
                        let hitY = pgy !== gy;

                        if (hitX) this.dx = -this.dx;
                        if (hitY) this.dy = -this.dy;
                        if (!hitX && !hitY) {
                            this.dx = -this.dx;
                            this.dy = -this.dy;
                        }

                        const speedMag = Math.hypot(this.dx, this.dy);
                        const angle = Math.atan2(this.dy, this.dx);
                        const jitter = (Math.random() - 0.5) * 0.5;
                        const newAngle = angle + jitter;
                        
                        this.dx = Math.cos(newAngle) * speedMag;
                        this.dy = Math.sin(newAngle) * speedMag;

                        this.bounceCooldown = 4;
                    }
                }
                this.x += this.dx;
                this.y += this.dy;
            }

            usePowerUp(gx, gy) {
                if (this.powerUpType === POWERUP_BOMB) {
                    const rad = 5;
                    let damaged = false;

                    for (let y = -rad; y <= rad; y++) {
                        for (let x = -rad; x <= rad; x++) {
                            let ny = gy + y;
                            let nx = gx + x;
                            if (ny >= 0 && ny < ROWS && nx >= 0 && nx < COLS) {
                                if (x*x + y*y <= rad*rad) grid[ny][nx] = this.owner;
                            }
                        }
                    }
                    
                    balls.forEach(b => {
                        if (b.owner !== this.owner && b.health > 0) {
                            const dist = Math.hypot(b.x - gx, b.y - gy);
                            if (dist < rad) {
                                b.health = Math.max(0, b.health - 20); 
                                damaged = true;
                            }
                        }
                    });

                    if (damaged) {
                        updateHealthBars();
                    }
                } else if (this.powerUpType === POWERUP_SWAP) {
                    handleHealthSwap();
                }
                
                this.powerUpType = null;
            }


            draw() {
                const px = OFFSET_X + this.x * TILE_SIZE;
                const py = OFFSET_Y + this.y * TILE_SIZE;
                const pr = Math.max(3, this.radius * TILE_SIZE);
                const player = players[this.owner];

                ctx.save();
                ctx.translate(px, py);

                // Drop Shadow
                ctx.shadowBlur = 10;
                ctx.shadowColor = "rgba(255, 255, 255, 0.8)";
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;

                // PowerUp Glow (If active)
                if (this.powerUpType !== null) {
                    const color = this.powerUpType === POWERUP_BOMB ? "#FFD700" : "#E0B0FF";
                    const flicker = 0.7 + Math.sin(Date.now()/100)*0.2;
                    ctx.beginPath();
                    ctx.arc(0, 0, pr + 3, 0, Math.PI * 2);
                    ctx.strokeStyle = `rgba(${parseInt(color.slice(1,3), 16)}, ${parseInt(color.slice(3,5), 16)}, ${parseInt(color.slice(5,7), 16)}, ${flicker})`;
                    ctx.lineWidth = 4;
                    ctx.stroke();
                }

                // CRITICAL: Draw Image if available, otherwise draw a circle
                if (player.loadedImage) {
                    // Draw image centered and scaled to fit the ball radius (pr)
                    const imgSize = pr * 2;
                    // Draw a white outline for visibility
                    ctx.beginPath();
                    ctx.arc(0, 0, pr + 1.5, 0, Math.PI * 2); 
                    ctx.fillStyle = "#fff";
                    ctx.fill();

                    // Clip to a circle for the image
                    ctx.beginPath();
                    ctx.arc(0, 0, pr, 0, Math.PI * 2);
                    ctx.clip(); 

                    // Draw the image
                    ctx.drawImage(player.loadedImage, -pr, -pr, imgSize, imgSize);
                    
                    // The health ring will be drawn outside the save/restore block below
                } else {
                    // Fallback: Draw Circle (As before)
                    ctx.beginPath();
                    ctx.arc(0, 0, pr + 1.5, 0, Math.PI * 2); 
                    ctx.fillStyle = "#fff";
                    ctx.fill();

                    ctx.beginPath();
                    ctx.arc(0, 0, pr, 0, Math.PI * 2);
                    ctx.fillStyle = player.color;
                    ctx.fill();
                }

                ctx.restore();
                
                // Draw Health Indicator (Player-colored Ring)
                ctx.beginPath();
                const startAngle = -Math.PI / 2;
                const endAngle = startAngle + (this.health / MAX_BALL_HEALTH) * Math.PI * 2;
                ctx.arc(px, py, pr + 2, startAngle, endAngle);
                
                ctx.strokeStyle = player.color;
                
                ctx.lineWidth = 3; 
                ctx.stroke();
            }
        }

        class PowerUp {
            constructor() {
                this.active = false; this.x = 0; this.y = 0; this.pulse = 0; this.timer = 0;
                this.type = POWERUP_BOMB; 
            }
            update() {
                if(this.active) this.pulse += 0.1;
                else {
                    this.timer++;
                    if(this.timer > 600 && Math.random() < 0.005) this.spawn();
                }
            }
            spawn() {
                this.active = true;
                this.x = 2 + Math.random() * (COLS - 4);
                this.y = 2 + Math.random() * (ROWS - 4);
                this.timer = 0;
                
                this.type = Math.random() < SWAP_RARITY_THRESHOLD ? POWERUP_SWAP : POWERUP_BOMB; 
            }
            draw() {
                if(!this.active) return;
                const px = OFFSET_X + this.x * TILE_SIZE;
                const py = OFFSET_Y + this.y * TILE_SIZE;
                const size = Math.max(6, TILE_SIZE * 0.5 * (0.8 + Math.sin(this.pulse)*0.2));

                ctx.save();
                ctx.translate(px, py);

                ctx.shadowBlur = 15;
                ctx.shadowColor = this.type === POWERUP_BOMB ? "#FFD700" : "#E0B0FF";

                if(this.type === POWERUP_BOMB) {
                    // Territory Bomb (Gold Square)
                    ctx.rotate(Math.PI/4);
                    ctx.fillStyle = "#FFD700";
                    ctx.fillRect(-size/2, -size/2, size, size);
                } else {
                    // Health Swap (Magenta Cross)
                    ctx.fillStyle = "#E0B0FF"; 
                    ctx.fillRect(-size/4, -size, size/2, size*2);
                    ctx.rotate(Math.PI/2);
                    ctx.fillRect(-size/4, -size, size/2, size*2);
                }

                ctx.restore();
            }
        }

        // --- CORE LOGIC ---

        function initGrid() {
            grid = [];
            for (let y = 0; y < ROWS; y++) {
                let row = [];
                for (let x = 0; x < COLS; x++) {
                    row.push(x < COLS / 2 ? 0 : 1);
                }
                grid.push(row);
            }
        }
        
        function drawGrid() {
            if (players.length < 2) return; 
            
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    const fillSize = TILE_SIZE + 1; 
                    const ownerIndex = grid[y][x];
                    
                    if (ownerIndex in players) {
                        let color = players[ownerIndex].color;
                        
                        if (showBorderEffect && isBorderTile(x, y, ownerIndex)) {
                            color = darkenHexColor(color, DARKEN_AMOUNT);
                        }

                        ctx.fillStyle = color;
                        ctx.fillRect(
                            OFFSET_X + x * TILE_SIZE, 
                            OFFSET_Y + y * TILE_SIZE, 
                            fillSize, 
                            fillSize
                        );
                    }
                }
            }
        }
        
        // Helper function to find all connected components (chunks) of territory for both players
        function findTerritoryChunks() {
            let chunks = [[], []]; // [Player 0 Chunks, Player 1 Chunks]
            let visited = Array(ROWS).fill(0).map(() => Array(COLS).fill(false));

            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    if (!visited[y][x]) {
                        const owner = grid[y][x];
                        let currentChunk = [];
                        let queue = [{ x, y }];
                        visited[y][x] = true;

                        while (queue.length > 0) {
                            const { x: cx, y: cy } = queue.shift();
                            currentChunk.push({ x: cx, y: cy });

                            const neighbors = [
                                { dx: 0, dy: -1 }, { dx: 0, dy: 1 }, 
                                { dx: -1, dy: 0 }, { dx: 1, dy: 0 }
                            ];

                            for (const { dx, dy } of neighbors) {
                                const nx = cx + dx;
                                const ny = cy + dy;

                                if (ny >= 0 && ny < ROWS && nx >= 0 && nx < COLS && 
                                    !visited[ny][nx] && grid[ny][nx] === owner) {
                                    visited[ny][nx] = true;
                                    queue.push({ x: nx, y: ny });
                                }
                            }
                        }
                        chunks[owner].push(currentChunk);
                    }
                }
            }
            return chunks;
        }

        function drawTerritoryLabels() {
            if (!showTerritoryNames || players.length < 2) return;

            const allChunks = findTerritoryChunks();

            for (let i = 0; i < 2; i++) {
                const playerChunks = allChunks[i];
                const name = players[i].name;

                playerChunks.forEach(chunk => {
                    const n = chunk.length;
                    
                    if (n < MIN_CHUNK_SIZE_FOR_LABEL) return; 

                    // Calculate Centroid (for axis calculation)
                    let sumX = 0, sumY = 0;
                    for(let p of chunk) { sumX += p.x; sumY += p.y; }
                    const cx = sumX / n;
                    const cy = sumY / n;

                    // Calculate Visual Center using Median
                    const xCoords = chunk.map(p => p.x).sort((a, b) => a - b);
                    const yCoords = chunk.map(p => p.y).sort((a, b) => a - b);
                    
                    const midIndex = Math.floor(n / 2);
                    const midX = xCoords[midIndex];
                    const midY = yCoords[midIndex];


                    // Principal Axis (Orientation)
                    let covXX = 0, covXY = 0, covYY = 0;
                    for(let p of chunk) {
                        covXX += (p.x - cx) * (p.x - cx);
                        covXY += (p.x - cx) * (p.y - cy);
                        covYY += (p.y - cy) * (p.y - cy);
                    }
                    const theta = 0.5 * Math.atan2(2 * covXY, covXX - covYY);

                    // Simple bounding box (for scale)
                    const cos = Math.cos(-theta);
                    const sin = Math.sin(-theta);
                    let minU = Infinity, maxU = -Infinity;
                    let minV = Infinity, maxV = -Infinity;
                    
                    for(let p of chunk) {
                        const dx = p.x - cx;
                        const dy = p.y - cy;
                        const u = dx * cos - dy * sin;
                        const v = dx * sin + dy * cos;
                        minU = Math.min(minU, u); maxU = Math.max(maxU, u);
                        minV = Math.min(minV, v); maxV = Math.max(maxV, v);
                    }
                    const width = maxU - minU;
                    const height = maxV - minV;
                    
                    // Font Size Calculation
                    const nameLengthFactor = name.length * 1.8;
                    const baseSize = Math.min(width * TILE_SIZE / nameLengthFactor, height * TILE_SIZE * 0.7);
                    const fontSize = Math.max(12, Math.min(100, baseSize)); 

                    // --- RENDERING ---
                    ctx.save();
                    ctx.translate(OFFSET_X + (midX + 0.5) * TILE_SIZE, OFFSET_Y + (midY + 0.5) * TILE_SIZE);
                    ctx.rotate(theta);

                    ctx.font = `900 ${fontSize}px 'Segoe UI', sans-serif`;
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillStyle = "rgba(255, 255, 255, 0.7)"; 
                    ctx.strokeStyle = "rgba(0,0,0,0.5)";       
                    ctx.lineWidth = 4; 

                    const totalWidth = ctx.measureText(name).width;
                    const maxAllowedWidth = width * TILE_SIZE * 0.95;
                    let scaleFactor = 1;
                    
                    if (totalWidth > maxAllowedWidth) {
                        scaleFactor = maxAllowedWidth / totalWidth;
                        ctx.scale(scaleFactor, scaleFactor);
                    }

                    ctx.strokeText(name, 0, 0);
                    ctx.fillText(name, 0, 0);
                    
                    ctx.restore();
                });
            }
        }

        function updateHealthBars() {
            if (players.length < 2) return; 

            const p1Max = players[0].maxHealth;
            const p2Max = players[1].maxHealth;
            
            balls = balls.filter(b => b.health > 0);

            const p1Current = calculateTotalHealth(0);
            const p2Current = calculateTotalHealth(1);
            
            hpBar1.style.width = (p1Current / p1Max * 100) + "%";
            hpBar2.style.width = (p2Current / p2Max * 100) + "%";

            if (p1Current <= 0 && p2Current > 0) endGame(1);
            else if (p2Current <= 0 && p1Current > 0) endGame(0);
            else if (p1Current <= 0 && p2Current <= 0) endGame(Math.random() > 0.5 ? 0 : 1); 
        }

        function endGame(winnerIdx) {
            isRunning = false;
            cancelAnimationFrame(animationId);
            winnerText.innerText = players[winnerIdx].name + " WINS!";
            winnerText.style.color = players[winnerIdx].color;
            victoryScreen.classList.remove('hidden');
        }

        function loop() {
            if (!isRunning) return;

            for(let i=0; i<simulationSpeed; i++) {
                balls.forEach(b => b.update());
                if(powerUp) powerUp.update();
                
                if (calculateTotalHealth(0) <= 0 || calculateTotalHealth(1) <= 0) {
                    updateHealthBars(); 
                    break;
                }
            }

            ctx.clearRect(0,0, canvas.width, canvas.height);
            drawGrid();
            drawTerritoryLabels(); 
            if(powerUp) powerUp.draw();
            balls.forEach(b => b.draw());

            animationId = requestAnimationFrame(loop);
        }

        // --- UI CONTROLS ---

        function updateGameUIControls() {
             // Territory Names
            if (showTerritoryNames) {
                nameToggleGame.innerText = "Names: ON";
                nameToggleGame.classList.add('on');
            } else {
                nameToggleGame.innerText = "Names: OFF";
                nameToggleGame.classList.remove('on');
            }
            
            // Border Effect
            if (showBorderEffect) {
                borderToggleGame.innerText = "Borders: ON";
                borderToggleGame.classList.add('border-on');
                borderToggleGame.classList.remove('on');
            } else {
                borderToggleGame.innerText = "Borders: OFF";
                borderToggleGame.classList.remove('border-on');
                borderToggleGame.classList.remove('on'); 
            }
        }


        function toggleTerritoryNames() {
            showTerritoryNames = !showTerritoryNames;
            nameToggleMenu.checked = showTerritoryNames; 
            updateGameUIControls();
        }

        function toggleBorderEffect() {
            showBorderEffect = !showBorderEffect;
            borderToggleMenu.checked = showBorderEffect;
            updateGameUIControls();
        }
        
        /**
         * Applies the settings of a predefined scenario to the menu inputs.
         */
        function applyScenario(scenarioName) {
            const scenario = SCENARIOS[scenarioName];
            if (!scenario) return;

            // General Configuration
            colsInput.value = scenario.cols;
            rowsInput.value = scenario.rows;
            ballCountInput.value = scenario.balls;
            ballSpeedInput.value = scenario.speed;

            // Display Options (Updates Menu Checkboxes and Global State)
            showTerritoryNames = nameToggleMenu.checked = scenario.showNames;
            showBorderEffect = borderToggleMenu.checked = scenario.showBorders;
        }

        
        // --- INIT ---

        async function startSimulation() {
            COLS = parseInt(colsInput.value) || 15;
            ROWS = parseInt(rowsInput.value) || 15;
            const ballCount = parseInt(ballCountInput.value) || 1;
            const speed = parseFloat(ballSpeedInput.value) || 0.10;
            
            showTerritoryNames = nameToggleMenu.checked;
            showBorderEffect = borderToggleMenu.checked;
            updateGameUIControls();

            const maxTotalHP = MAX_BALL_HEALTH * ballCount;

            // Update player configs from inputs
            players[0].name = p1NameInput.value || "Player 1";
            players[0].color = p1ColorInput.value;
            players[0].maxHealth = maxTotalHP;

            players[1].name = p2NameInput.value || "Player 2";
            players[1].color = p2ColorInput.value;
            players[1].maxHealth = maxTotalHP;


            handleResize(); 
            initGrid(); 
            balls = [];

            for(let i=0; i<ballCount; i++) {
                const startX1 = (COLS * 0.25) + (Math.random()*2 - 1);
                const startY1 = (ROWS * 0.5) + (Math.random()*2 - 1);
                const startX2 = (COLS * 0.75) + (Math.random()*2 - 1);
                const startY2 = (ROWS * 0.5) + (Math.random()*2 - 1);

                balls.push(new Ball(startX1, startY1, speed * (Math.random() > 0.5 ? 1 : -1), speed * (Math.random() > 0.5 ? 1 : -1), 0));
                balls.push(new Ball(startX2, startY2, speed * (Math.random() > 0.5 ? 1 : -1), speed * (Math.random() > 0.5 ? 1 : -1), 1));
            }

            powerUp = new PowerUp();
            nameDisp1.innerText = players[0].name; nameDisp1.style.color = players[0].color; hpBar1.style.background = players[0].color;
            nameDisp2.innerText = players[1].name; nameDisp2.style.color = players[1].color; hpBar2.style.background = players[1].color;
            
            updateHealthBars(); 

            mainMenu.classList.add('hidden');
            victoryScreen.classList.add('hidden');
            appLayout.classList.remove('ui-hidden');
            isRunning = true;
            loop();
        }

        function resetToMenu() { 
            isRunning = false; 
            cancelAnimationFrame(animationId);
            grid = []; 
            applyScenario('Duel');
            
            nameToggleMenu.checked = showTerritoryNames;
            borderToggleMenu.checked = showBorderEffect;
            
            victoryScreen.classList.add('hidden'); 
            mainMenu.classList.remove('hidden'); 
            appLayout.classList.add('ui-hidden'); 
            
            ctx.clearRect(0, 0, canvas.width, canvas.height); 
        }
        
        function stopSimulation() { 
            isRunning = false; 
            cancelAnimationFrame(animationId); 
            grid = []; 
            applyScenario('Duel');

            mainMenu.classList.remove('hidden'); 
            appLayout.classList.add('ui-hidden'); 
            
            ctx.clearRect(0, 0, canvas.width, canvas.height); 
        }
        
        function setSpeed(val) {
            simulationSpeed = val;
            speedBtns.forEach((b) => { if(parseInt(b.innerText) === val) b.classList.add('active'); else b.classList.remove('active'); });
        }
        
        // Initial setup on load: Apply Duel scenario defaults
        window.onload = function() {
            applyScenario('Duel');
            handleResize();
        }

    </script>
</body>
</html>
