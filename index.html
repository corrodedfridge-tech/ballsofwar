<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Territory Battle Pro</title>
    <style>
        :root {
            --bg-color: #050505;
            --text-color: #fff;
            --accent: #FFD700;
            --danger: #ff4444;
            --bar-bg: #333;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* Layout Grid */
        #app-layout {
            display: grid;
            grid-template-rows: 60px 1fr 60px;
            height: 100%;
            width: 100%;
            transition: all 0.3s ease;
        }

        /* Top Bar */
        #top-bar {
            background: linear-gradient(to bottom, rgba(0, 0, 0, 0.95), rgba(0,0,0,0));
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 40px;
            z-index: 20;
            position: absolute;
            top: 0;
            width: 100%;
            box-sizing: border-box;
            pointer-events: none;
        }

        .player-status {
            display: flex;
            flex-direction: column;
            width: 35%;
            gap: 5px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        }

        .player-name {
            font-size: 1.1rem;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .health-track {
            width: 100%;
            height: 12px;
            background: rgba(255,255,255,0.1);
            border-radius: 6px;
            overflow: hidden;
            position: relative;
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255,255,255,0.1);
        }

        .health-fill {
            height: 100%;
            width: 100%;
            transition: width 0.2s, background-color 0.3s;
        }

        /* Game Area */
        #game-area {
            position: relative;
            background: #0a0a0a;
            width: 100%;
            height: 100%;
            overflow: hidden;
            grid-row: 1 / 4;
            grid-column: 1;
            z-index: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        canvas {
            display: block;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
        }

        /* Bottom Bar */
        #bottom-bar {
            position: absolute;
            bottom: 0;
            width: 100%;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.95), rgba(0,0,0,0));
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            z-index: 20;
            padding-bottom: 20px;
            padding-top: 40px;
            pointer-events: auto;
        }

        .ui-hidden #top-bar, .ui-hidden #bottom-bar { display: none; }

        /* Buttons */
        .speed-btn {
            background: rgba(0,0,0,0.5);
            border: 1px solid #555;
            color: #ccc;
            padding: 8px 16px;
            font-size: 0.9rem;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            backdrop-filter: blur(4px);
        }
        .speed-btn:hover { background: #444; }
        .speed-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: #000;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
        }

        .btn-stop {
            background-color: var(--danger);
            border: none;
            color: white;
            padding: 8px 24px;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
            margin-left: 20px;
            box-shadow: 0 0 10px rgba(255,68,68,0.3);
        }

        /* Overlays */
        .overlay {
            position: fixed; 
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 50;
            transition: opacity 0.3s;
        }
        .hidden { opacity: 0; pointer-events: none; z-index: -1; }

        h1 {
            font-size: clamp(2rem, 5vw, 4rem);
            text-transform: uppercase;
            background: linear-gradient(to right, #fff, #888);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 30px;
            text-align: center;
        }

        .menu-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 30px;
            margin-bottom: 40px;
            width: 80%;
            max-width: 800px;
        }

        .player-config {
            background: rgba(255,255,255,0.05);
            padding: 25px;
            border-radius: 12px;
            border: 1px solid #333;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .config-title {
            color: #aaa;
            font-size: 0.8rem;
            font-weight: bold;
            text-transform: uppercase;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
            margin-bottom: 5px;
        }

        .input-group label {
            display: block;
            font-size: 0.8rem;
            margin-bottom: 5px;
            color: #888;
        }

        .input-group input[type="text"], .input-group input[type="number"] {
            width: 100%;
            padding: 8px;
            background: #222;
            border: 1px solid #444;
            color: white;
            border-radius: 4px;
            box-sizing: border-box;
        }

        .input-group input[type="file"] {
            width: 100%;
            padding: 8px;
            background: #222;
            border: 1px solid #444;
            color: #888;
            border-radius: 4px;
            box-sizing: border-box;
            font-size: 0.8rem;
            cursor: pointer;
        }

        .input-group input[type="color"] {
            width: 100%; height: 40px; border: none; background: none; cursor: pointer;
        }

        .btn-start {
            background: linear-gradient(135deg, #FFD700, #FFA500);
            color: #000;
            font-size: 1.5rem;
            padding: 20px 80px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.2);
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.2s ease;
        }
        .btn-start:hover { transform: scale(1.05); box-shadow: 0 0 30px rgba(255, 215, 0, 0.4); }
        .btn-secondary {
            background: #444; color: #fff; padding: 10px 30px;
            border: none; border-radius: 4px; cursor: pointer; font-weight: bold; margin-top: 20px;
        }

    </style>
</head>
<body>

    <div id="app-layout" class="ui-hidden">
        
        <div id="top-bar">
            <div class="player-status">
                <div class="health-track"><div id="hp-bar-1" class="health-fill" style="background: #00d2ff; width: 100%;"></div></div>
                <div id="name-display-1" class="player-name" style="color: #00d2ff; text-align: left;">Player 1</div>
            </div>
            <div style="font-weight:900; color:#fff; font-size:1.5rem; text-shadow:0 0 10px #000;">VS</div>
            <div class="player-status">
                <div class="health-track"><div id="hp-bar-2" class="health-fill" style="background: #ff2a6d; width: 100%;"></div></div>
                <div id="name-display-2" class="player-name" style="color: #ff2a6d; text-align: right;">Player 2</div>
            </div>
        </div>

        <div id="game-area">
            <canvas id="simCanvas"></canvas>
            
            <div id="main-menu" class="overlay">
                <h1>Territory Wars</h1>
                <div class="menu-grid">
                    <div class="player-config" style="grid-column: 1 / -1; flex-direction:row; justify-content: space-around;">
                         <div class="input-group">
                            <label>Grid Size (Cols x Rows)</label>
                            <div style="display:flex; gap:10px;">
                                <input type="number" id="colsInput" value="80" style="width:70px;">
                                <input type="number" id="rowsInput" value="60" style="width:70px;">
                            </div>
                        </div>
                        <div class="input-group">
                            <label>Balls Per Player</label>
                            <input type="number" id="ballCountInput" value="10" min="1" max="100" style="width:80px;">
                        </div>
                    </div>
                    <div class="player-config">
                        <div class="config-title">Player 1</div>
                        <div class="input-group"><label>Name</label><input type="text" id="p1-name" value="Blue Empire"></div>
                        <div class="input-group"><label>Upload Flag</label><input type="file" id="p1-file" accept="image/*"></div>
                        <div class="input-group"><label>Color</label><input type="color" id="p1-color" value="#00d2ff"></div>
                    </div>
                    <div class="player-config">
                        <div class="config-title">Player 2</div>
                        <div class="input-group"><label>Name</label><input type="text" id="p2-name" value="Red Kingdom"></div>
                        <div class="input-group"><label>Upload Flag</label><input type="file" id="p2-file" accept="image/*"></div>
                        <div class="input-group"><label>Color</label><input type="color" id="p2-color" value="#ff2a6d"></div>
                    </div>
                </div>
                <button class="btn-start" onclick="startSimulation()">START WAR</button>
            </div>

            <div id="victory-screen" class="overlay hidden">
                <h1 id="winner-text">BLUE WINS!</h1>
                <h2 style="color:#aaa; margin-top:-20px;">Enemy Eliminated</h2>
                <button class="btn-secondary" onclick="resetToMenu()">RETURN TO MENU</button>
            </div>
        </div>

        <div id="bottom-bar">
            <span style="color:#888; font-size: 0.8rem; font-weight:bold; letter-spacing:1px;">SPEED</span>
            <button class="speed-btn active" onclick="setSpeed(1)">1x</button>
            <button class="speed-btn" onclick="setSpeed(2)">2x</button>
            <button class="speed-btn" onclick="setSpeed(4)">4x</button>
            <button class="speed-btn" onclick="setSpeed(8)">8x</button>
            <button class="btn-stop" onclick="stopSimulation()">STOP</button>
        </div>
    </div>

    <script>
        // --- GLOBALS ---
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        const appLayout = document.getElementById('app-layout');
        const gameArea = document.getElementById('game-area');

        // Config
        let COLS = 80;
        let ROWS = 60;
        let TILE_SIZE = 10;
        let OFFSET_X = 0;
        let OFFSET_Y = 0;
        
        // Game State
        let grid = []; 
        let balls = [];
        let powerUp = null;
        let animationId;
        let isRunning = false;
        let simulationSpeed = 1;
        let players = []; 
        
        // UI Refs
        const mainMenu = document.getElementById('main-menu');
        const victoryScreen = document.getElementById('victory-screen');
        const hpBar1 = document.getElementById('hp-bar-1');
        const hpBar2 = document.getElementById('hp-bar-2');
        const nameDisp1 = document.getElementById('name-display-1');
        const nameDisp2 = document.getElementById('name-display-2');
        const winnerText = document.getElementById('winner-text');
        const speedBtns = document.querySelectorAll('.speed-btn');

        // --- RESIZE LOGIC (Proportional Squares) ---
        function handleResize() {
            const availW = gameArea.clientWidth;
            const availH = gameArea.clientHeight;
            
            const tileW = availW / COLS;
            const tileH = availH / ROWS;
            
            TILE_SIZE = Math.min(tileW, tileH);
            
            const mapW = TILE_SIZE * COLS;
            const mapH = TILE_SIZE * ROWS;
            
            OFFSET_X = (availW - mapW) / 2;
            OFFSET_Y = (availH - mapH) / 2;
            
            canvas.width = availW;
            canvas.height = availH;
            
            if(!isRunning && grid.length > 0) {
                drawGrid();
                drawTerritoryLabels();
            }
        }
        window.addEventListener('resize', handleResize);

        // --- ASSETS ---
        function readImageFile(inputElement) {
            return new Promise((resolve) => {
                if (inputElement.files && inputElement.files[0]) {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.readAsDataURL(inputElement.files[0]);
                } else { resolve(null); }
            });
        }

        async function getDominantColor(imgSrc, fallbackColor) {
            return new Promise((resolve) => {
                if (!imgSrc) { resolve({ color: fallbackColor, imgObj: null }); return; }
                const img = new Image();
                img.crossOrigin = "Anonymous"; 
                img.onload = function() {
                    try {
                        const vCanvas = document.createElement('canvas');
                        vCanvas.width = 1; vCanvas.height = 1;
                        const vCtx = vCanvas.getContext('2d');
                        vCtx.drawImage(img, 0, 0, 1, 1);
                        const p = vCtx.getImageData(0, 0, 1, 1).data;
                        const hex = "#" + ((1 << 24) + (p[0] << 16) + (p[1] << 8) + p[2]).toString(16).slice(1);
                        resolve({ color: hex, imgObj: img });
                    } catch (e) { resolve({ color: fallbackColor, imgObj: img }); }
                };
                img.onerror = () => resolve({ color: fallbackColor, imgObj: null });
                img.src = imgSrc;
            });
        }

        // --- CLASSES ---
        
        class Ball {
            constructor(x, y, dx, dy, ownerIndex) {
                this.x = x;
                this.y = y;
                this.dx = dx;
                this.dy = dy;
                this.owner = ownerIndex;
                this.radius = 0.6; // Ball is now roughly the size of a single tile
                this.bounceCooldown = 0;
                this.powerUpTime = 0;
            }

            update() {
                if (players[this.owner].health <= 0) return;

                if (this.bounceCooldown > 0) this.bounceCooldown--;
                if (this.powerUpTime > 0) this.powerUpTime--;

                let nextX = this.x + this.dx;
                let nextY = this.y + this.dy;

                // Map Boundaries
                if (nextX - this.radius < 0 || nextX + this.radius > COLS) {
                    this.dx = -this.dx;
                    nextX = this.x + this.dx;
                }
                if (nextY - this.radius < 0 || nextY + this.radius > ROWS) {
                    this.dy = -this.dy;
                    nextY = this.y + this.dy;
                }

                // PowerUp
                if (powerUp && powerUp.active) {
                    const dist = Math.hypot(this.x - powerUp.x, this.y - powerUp.y);
                    if (dist < (this.radius + 1.2)) {
                        powerUp.active = false;
                        this.powerUpTime = 600;
                    }
                }

                // Grid Interaction
                let checkX = this.x + (this.dx * 1.5);
                let checkY = this.y + (this.dy * 1.5);
                
                let gx = Math.floor(checkX);
                let gy = Math.floor(checkY);
                gx = Math.max(0, Math.min(COLS - 1, gx));
                gy = Math.max(0, Math.min(ROWS - 1, gy));

                const tileOwner = grid[gy][gx];

                if (tileOwner !== this.owner) {
                    if (this.powerUpTime > 0) this.explodeTerritory(gx, gy);
                    else grid[gy][gx] = this.owner; // Capture only one tile

                    if (this.bounceCooldown === 0) {
                        let pgx = Math.floor(this.x);
                        let pgy = Math.floor(this.y);
                        
                        let hitX = pgx !== gx;
                        let hitY = pgy !== gy;

                        if (hitX) this.dx = -this.dx;
                        if (hitY) this.dy = -this.dy;
                        if (!hitX && !hitY) {
                            this.dx = -this.dx;
                            this.dy = -this.dy;
                        }

                        // Jitter
                        const speed = Math.hypot(this.dx, this.dy);
                        const angle = Math.atan2(this.dy, this.dx);
                        const jitter = (Math.random() - 0.5) * 0.5;
                        const newAngle = angle + jitter;
                        
                        this.dx = Math.cos(newAngle) * speed;
                        this.dy = Math.sin(newAngle) * speed;

                        this.bounceCooldown = 4;
                    }
                }
                this.x += this.dx;
                this.y += this.dy;
            }

            explodeTerritory(gx, gy) {
                const rad = 5;
                for (let y = -rad; y <= rad; y++) {
                    for (let x = -rad; x <= rad; x++) {
                        let ny = gy + y;
                        let nx = gx + x;
                        if (ny >= 0 && ny < ROWS && nx >= 0 && nx < COLS) {
                            if (x*x + y*y <= rad*rad) grid[ny][nx] = this.owner;
                        }
                    }
                }
                balls.forEach(b => {
                    if (b.owner !== this.owner && players[b.owner].health > 0) {
                        const dist = Math.hypot(b.x - gx, b.y - gy);
                        if (dist < rad) {
                            players[b.owner].health = Math.max(0, players[b.owner].health - 20);
                            updateHealthBars();
                        }
                    }
                });
            }

            draw() {
                if (players[this.owner].health <= 0) return;

                const px = OFFSET_X + this.x * TILE_SIZE;
                const py = OFFSET_Y + this.y * TILE_SIZE;
                const pr = Math.max(3, this.radius * TILE_SIZE);

                ctx.save();
                ctx.translate(px, py);

                if (this.powerUpTime > 0) {
                    ctx.beginPath();
                    ctx.arc(0, 0, pr + 4, 0, Math.PI * 2);
                    ctx.strokeStyle = `rgba(255, 215, 0, ${0.5 + Math.sin(Date.now()/100)*0.4})`;
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }

                // High visibility outer stroke
                ctx.beginPath();
                ctx.arc(0, 0, pr + 1.5, 0, Math.PI * 2); // Slight white border
                ctx.fillStyle = "#fff";
                ctx.fill();

                // Inner circle (image or color)
                ctx.beginPath();
                ctx.arc(0, 0, pr, 0, Math.PI * 2);
                ctx.closePath();
                ctx.clip(); 

                const pInfo = players[this.owner];
                if (pInfo.img) {
                    try { ctx.drawImage(pInfo.img, -pr, -pr, pr*2, pr*2); } 
                    catch(e) { ctx.fillStyle = pInfo.color; ctx.fill(); }
                } else {
                    ctx.fillStyle = pInfo.color;
                    ctx.fill();
                }
                ctx.restore();
            }
        }

        class PowerUp {
            constructor() {
                this.active = false; this.x = 0; this.y = 0; this.pulse = 0; this.timer = 0;
            }
            update() {
                if(this.active) this.pulse += 0.1;
                else {
                    this.timer++;
                    if(this.timer > 300 && Math.random() < 0.01) this.spawn();
                }
            }
            spawn() {
                this.active = true;
                this.x = 2 + Math.random() * (COLS - 4);
                this.y = 2 + Math.random() * (ROWS - 4);
                this.timer = 0;
            }
            draw() {
                if(!this.active) return;
                const px = OFFSET_X + this.x * TILE_SIZE;
                const py = OFFSET_Y + this.y * TILE_SIZE;
                const size = Math.max(6, TILE_SIZE * 2 * (1.2 + Math.sin(this.pulse)*0.2));

                ctx.save();
                ctx.translate(px, py);
                ctx.rotate(Math.PI/4);
                ctx.fillStyle = "#FFD700";
                ctx.shadowBlur = 15;
                ctx.shadowColor = "#FFD700";
                ctx.fillRect(-size/2, -size/2, size, size);
                ctx.restore();
            }
        }

        // --- CORE LOGIC ---

        function initGrid() {
            grid = [];
            for (let y = 0; y < ROWS; y++) {
                let row = [];
                for (let x = 0; x < COLS; x++) {
                    row.push(x < COLS / 2 ? 0 : 1);
                }
                grid.push(row);
            }
        }
        
        function drawGrid() {
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    ctx.fillStyle = players[grid[y][x]].color;
                    ctx.fillRect(
                        OFFSET_X + x * TILE_SIZE, 
                        OFFSET_Y + y * TILE_SIZE, 
                        TILE_SIZE + 0.8, 
                        TILE_SIZE + 0.8
                    );
                }
            }
        }

        function drawTerritoryLabels() {
            const STEP = 2; 
            let points = [[], []];

            for (let y = 0; y < ROWS; y += STEP) {
                for (let x = 0; x < COLS; x += STEP) {
                    points[grid[y][x]].push({x, y});
                }
            }

            for(let i=0; i<2; i++) {
                if(players[i].health <= 0 || points[i].length < 20) continue;

                const pts = points[i];
                const n = pts.length;

                // 1. Centroid
                let sumX = 0, sumY = 0;
                for(let p of pts) { sumX += p.x; sumY += p.y; }
                const cx = sumX / n;
                const cy = sumY / n;

                // 2. Covariance (Angle)
                let covXX = 0, covXY = 0, covYY = 0;
                for(let p of pts) {
                    covXX += (p.x - cx) * (p.x - cx);
                    covXY += (p.x - cx) * (p.y - cy);
                    covYY += (p.y - cy) * (p.y - cy);
                }
                const theta = 0.5 * Math.atan2(2 * covXY, covXX - covYY);
                
                // 3. Spread
                const cos = Math.cos(-theta);
                const sin = Math.sin(-theta);
                let minU = Infinity, maxU = -Infinity;
                let minV = Infinity, maxV = -Infinity;
                
                for(let p of pts) {
                    const dx = p.x - cx;
                    const dy = p.y - cy;
                    const u = dx * cos - dy * sin;
                    const v = dx * sin + dy * cos;
                    minU = Math.min(minU, u); maxU = Math.max(maxU, u);
                    minV = Math.min(minV, v); maxV = Math.max(maxV, v);
                }
                const width = maxU - minU;
                const height = maxV - minV;

                // 4. Curvature
                let bendAccumulator = 0;
                let sampleCount = 0;
                for(let p of pts) {
                    const dx = p.x - cx;
                    const dy = p.y - cy;
                    const u = dx * cos - dy * sin;
                    const v = dx * sin + dy * cos;
                    
                    if (Math.abs(u) > width * 0.3) {
                         const normU = u / (width/2);
                         if(Math.abs(normU) > 0.1) {
                            bendAccumulator += v / (normU * normU);
                            sampleCount++;
                         }
                    }
                }
                const curvature = (sampleCount > 0 ? bendAccumulator / sampleCount : 0) * 1.5;

                // --- RENDERING ---
                ctx.save();
                ctx.translate(OFFSET_X + cx * TILE_SIZE, OFFSET_Y + cy * TILE_SIZE);
                ctx.rotate(theta);

                const name = players[i].name;
                const baseSize = Math.min(width * TILE_SIZE / name.length * 1.8, height * TILE_SIZE * 0.7);
                const fontSize = Math.max(12, Math.min(100, baseSize));

                ctx.font = `900 ${fontSize}px 'Segoe UI', sans-serif`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
                ctx.strokeStyle = "rgba(0,0,0,0.3)";
                ctx.lineWidth = 3;

                const totalWidth = ctx.measureText(name).width;
                const maxAllowedWidth = width * TILE_SIZE * 0.9;
                if (totalWidth > maxAllowedWidth) {
                    const scale = maxAllowedWidth / totalWidth;
                    ctx.scale(scale, scale);
                }

                let currentX = -totalWidth / 2;
                for (let char of name) {
                    const charW = ctx.measureText(char).width;
                    const charX = currentX + charW/2;
                    
                    const normX = charX / (totalWidth/2);
                    const yOffset = curvature * (normX * normX);
                    
                    ctx.save();
                    ctx.translate(charX, yOffset);
                    ctx.strokeText(char, 0, 0);
                    ctx.fillText(char, 0, 0);
                    ctx.restore();

                    currentX += charW;
                }
                ctx.restore();
            }
        }

        function updateHealthBars() {
            const p1 = players[0];
            const p2 = players[1];
            hpBar1.style.width = (p1.health / p1.maxHealth * 100) + "%";
            hpBar2.style.width = (p2.health / p2.maxHealth * 100) + "%";
            if (p1.health <= 0) endGame(1);
            else if (p2.health <= 0) endGame(0);
        }

        function endGame(winnerIdx) {
            isRunning = false;
            cancelAnimationFrame(animationId);
            winnerText.innerText = players[winnerIdx].name + " WINS!";
            winnerText.style.color = players[winnerIdx].color;
            victoryScreen.classList.remove('hidden');
        }

        function loop() {
            if (!isRunning) return;

            for(let i=0; i<simulationSpeed; i++) {
                balls.forEach(b => b.update());
                if(powerUp) powerUp.update();
                if(players[0].health <= 0 || players[1].health <= 0) break;
            }

            ctx.clearRect(0,0, canvas.width, canvas.height);
            drawGrid();
            drawTerritoryLabels(); 
            if(powerUp) powerUp.draw();
            balls.forEach(b => b.draw());

            animationId = requestAnimationFrame(loop);
        }

        // --- INIT ---

        async function startSimulation() {
            COLS = parseInt(document.getElementById('colsInput').value) || 80;
            ROWS = parseInt(document.getElementById('rowsInput').value) || 60;
            const ballCount = parseInt(document.getElementById('ballCountInput').value) || 10;
            
            const totalHP = 100 * ballCount;

            handleResize();

            const p1File = document.getElementById('p1-file');
            const p2File = document.getElementById('p2-file');
            const p1ImgSrc = await readImageFile(p1File);
            const p2ImgSrc = await readImageFile(p2File);
            const p1Color = document.getElementById('p1-color').value;
            const p2Color = document.getElementById('p2-color').value;
            const p1Data = await getDominantColor(p1ImgSrc, p1Color);
            const p2Data = await getDominantColor(p2ImgSrc, p2Color);

            players = [
                { name: document.getElementById('p1-name').value || "Player 1", color: p1Data.color, img: p1Data.imgObj, health: totalHP, maxHealth: totalHP },
                { name: document.getElementById('p2-name').value || "Player 2", color: p2Data.color, img: p2Data.imgObj, health: totalHP, maxHealth: totalHP }
            ];

            initGrid();
            balls = [];
            const speed = 0.35; 

            for(let i=0; i<ballCount; i++) {
                balls.push(new Ball((COLS * 0.25) + (Math.random()*6 - 3), (ROWS * 0.5) + (Math.random()*6 - 3), speed * (Math.random() > 0.5 ? 1 : -1), speed * (Math.random() > 0.5 ? 1 : -1), 0));
                balls.push(new Ball((COLS * 0.75) + (Math.random()*6 - 3), (ROWS * 0.5) + (Math.random()*6 - 3), speed * (Math.random() > 0.5 ? 1 : -1), speed * (Math.random() > 0.5 ? 1 : -1), 1));
            }

            powerUp = new PowerUp();
            nameDisp1.innerText = players[0].name; nameDisp1.style.color = players[0].color; hpBar1.style.background = players[0].color;
            nameDisp2.innerText = players[1].name; nameDisp2.style.color = players[1].color; hpBar2.style.background = players[1].color;
            updateHealthBars();

            mainMenu.classList.add('hidden');
            victoryScreen.classList.add('hidden');
            appLayout.classList.remove('ui-hidden');
            isRunning = true;
            loop();
        }

        function resetToMenu() { victoryScreen.classList.add('hidden'); mainMenu.classList.remove('hidden'); appLayout.classList.add('ui-hidden'); }
        function stopSimulation() { isRunning = false; cancelAnimationFrame(animationId); mainMenu.classList.remove('hidden'); appLayout.classList.add('ui-hidden'); }
        function setSpeed(val) {
            simulationSpeed = val;
            speedBtns.forEach((b) => { if(parseInt(b.innerText) === val) b.classList.add('active'); else b.classList.remove('active'); });
        }
    </script>
</body>
</html>
